-- 
미완성 입니다. / 
hufs_thread API를 사용하려 하였으나 지속적인 에러 발생,
Pthread 사용하니 undefined reference 에러가 발생합니다.
--

먼저, semaphore의 동작을 구현하기 위하여 enqueue함수와 dequeue함수를 구현했습니다.

enqueue 함수의 경우 sem과 pid의 값을 입력받고, waiters 배열의 -1인 자리에
pid값을 넣도록 하였습니다. 성공시 0을 return, 실패시 -1을 return 합니다.

dequeue 함수의 경우 sem만 입력을 받아 waiters 배열에서 값을 차례로 검색하여
pid에 저장, 이때의 값이 -1이 아니라면 waiters의 해당 자리를 -1로 비우고,
pid값을 retuen 합니다.
waiters의 값이 -1이라면 배열을 계속 돌아 -1이 아닌 값을 return 하도록 하였습니다.
만약, 모든 값이 -1인 경우인 배열이 비어있을 경우, -1을 return 합니다.

sem_wait 함수의 경우엔 함수에 진입하자마자 lock acq를 하였고, active가 0인지 확인했습니다.
active의 값이 0이라면 활성상태가 아니기 때문에, lock release를 실행.
그렇지 않은경우 value-- 를 한 뒤 value<0 인치 체크, 
맞다면 enqueue를 진행하고 block(sleep)처리
아니라면 바로 release 하도록 하였습니다.

sem_signal 함수의 경우 wait과 동일하게 함수 진입시 lock auq, active가 0이면 -1 return
value++ 실행 후 value<=0 여부 확인하여 조건 충족시 dequeue 하도록 하였습니다.
이때 dequeue의 return 값이 -1이면 lock release 후 실패인 -1을 return .
그렇지 않은 경우 해당 pid의 process가 wakeup하도록 하였습니다.
만약, wakeup의 return값이 -1이면 wakeup에 실패한것으로 lock release후 -1 return.
아니라면 lock release 후 성공의 0을 return 합니다.

procon.c 파일 안에는 consumer 함수와 producer 함수가 있습니다.
consumer 함수의 경우 con_mutex, con_full, con_empty의 semaphore가 있고,
producer 삼수의 경우 pro_mutex, pro_full, pro_empty의 semaphore가 있습니다. 
교재에 있는 bounded buffer와 유사하게 코드를 작성하였습니다.
